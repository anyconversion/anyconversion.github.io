<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="RealVibin Messages - Chat with other users in real-time.">
  <meta name="keywords" content="RealVibin, messaging, chat, social platform">
  <title>RealVibin Messages</title>
  <link href="https://fonts.googleapis.com/css2?family=Open+Sans:wght@400;600;700&display=swap" rel="stylesheet">
  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    tailwind.config = {
      theme: {
        extend: {
          colors: {
            primary: '#0080ff',
            secondary: '#ff4d4f',
            dark: '#1f2937'
          }
        }
      }
    }
  </script>
  <script src="https://cdn.jsdelivr.net/npm/react@18.2.0/umd/react.development.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/react-dom@18.2.0/umd/react-dom.development.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@babel/standalone@7.20.15/babel.min.js" crossorigin="anonymous"></script>
  <script type="module">
    import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js';
    import { getAuth, onAuthStateChanged, signInWithEmailAndPassword, signOut, setPersistence, browserSessionPersistence } from 'https://www.gstatic.com/firebasejs/10.12.2/firebase-auth.js';
    import { getFirestore, collection, addDoc, onSnapshot, orderBy, query, serverTimestamp, getDoc, doc, setDoc, updateDoc, arrayUnion, where, getDocs, writeBatch } from 'https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js';

    const firebaseConfig = {
      apiKey: "AIzaSyCZavBCNmUx2lX4SqdXlYdloCdwmw-hYT8",
      authDomain: "realvibin-9aac1.firebaseapp.com",
      projectId: "realvibin-9aac1",
      messagingSenderId: "155907884818",
      appId: "1:155907884818:web:d499ac21bc81c3273d55cb"
    };

    try {
      console.log('Initializing Firebase...');
      const app = initializeApp(firebaseConfig);
      const auth = getAuth(app);
      const db = getFirestore(app);
      console.log('Firebase initialized successfully');

      window.CLOUDINARY_CLOUD_NAME = "ddmrplnut";
      window.CLOUDINARY_UPLOAD_PRESET = "realvibin_unsigned";

      window.firebase = {
        app,
        auth,
        db,
        onAuthStateChanged,
        signInWithEmailAndPassword,
        signOut,
        setPersistence,
        browserSessionPersistence,
        collection,
        addDoc,
        onSnapshot,
        orderBy,
        query,
        serverTimestamp,
        getDoc,
        doc,
        setDoc,
        updateDoc,
        arrayUnion,
        where,
        getDocs,
        writeBatch
      };
      window.firebaseInitialized = true;
    } catch (error) {
      console.error('Firebase Initialization Error:', { message: error.message, code: error.code, stack: error.stack });
      window.firebaseError = error;
    }
  </script>
  <script src="./functions.js"></script>
  <style>
    body {
      font-family: 'Open Sans', Arial, sans-serif;
      background-color: #f3f4f6;
      margin: 0;
    }
    .form-input {
      width: 100%;
      padding: 0.5rem;
      border: 1px solid #d1d5db;
      border-radius: 0.375rem;
    }
    .form-label {
      display: block;
      font-weight: 600;
      margin-bottom: 0.25rem;
    }
    .message-container {
      margin-top: 100px;
      min-height: calc(100vh - 100px);
      max-height: calc(100vh - 100px);
      background: white;
      border-radius: 0.5rem;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    }
    .message-list {
      border: 1px solid #e5e7eb;
      overflow-y: auto;
      padding: 0.5rem;
    }
    .message-list > div {
      border: 1px solid #e5e7eb;
      border-radius: 0.375rem;
      margin-bottom: 0.5rem;
      padding: 0.75rem;
    }
    .conversation-view {
      border: 1px solid #e5e7eb;
      padding: 0.5rem;
    }
    .messages-area {
      flex-grow: 1;
      overflow-y: auto;
    }
    .message-input {
      background: white;
      padding: 0.5rem 0;
      border-top: 1px solid #e5e7eb;
    }
    .message-bubble {
      max-width: 75%;
    }
    .container {
      width: 100%;
      max-width: 1024px;
      margin: 0 auto;
      padding: 0 1rem;
      box-sizing: border-box;
      background: transparent;
    }
    nav.msgHeader {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      z-index: 1000;
      background-color: #0080ff;
    }
    @media (max-width: 639px) {
      .container {
        margin: 0;
        padding: 0 0.5rem;
        max-width: 100%;
      }
      .message-container {
        margin-top: 72px;
        min-height: calc(100vh - 72px);
        max-height: calc(100vh - 72px);
      }
      .conversation-view {
        min-height: calc(100vh - 72px);
      }
      .message-list {
        border-bottom: 1px solid #e5e7eb;
        border-right: none;
      }
      .translate-x-full { transform: translateX(100%); }
      .-translate-x-full { transform: translateX(-100%); }
      .translate-x-0 { transform: translateX(0); }
    }
    @media (min-width: 640px) {
      .transform-none { transform: none !important; }
      .duration-0 { transition-duration: 0ms !important; }
    }
  </style>
</head>
<body>
  <div id="root"></div>
  <script type="text/babel" data-presets="env,react">
    if (!window.React || !window.ReactDOM || !window.Babel) {
      console.error('Required libraries not loaded.');
      document.getElementById('root').innerHTML = '<div className="error"><h2>Error</h2><p>Failed to load essential libraries.</p></div>';
      throw new Error('React, ReactDOM, or Babel is not available');
    }

    // Error Boundary to catch runtime errors
    class ErrorBoundary extends React.Component {
      state = { error: null };
      static getDerivedStateFromError(error) {
        return { error };
      }
      render() {
        if (this.state.error) {
          return (
            <div className="container text-center mt-20">
              <p className="text-red-600">Error: {this.state.error.message}</p>
            </div>
          );
        }
        return this.props.children;
      }
    }

    const fetchUserProfile = async (userId, isUsername = false) => {
      console.log('fetchUserProfile called:', { userId, isUsername });
      try {
        let actualUserId = userId;
        if (isUsername) {
          const usernameDoc = await window.firebase.getDoc(window.firebase.doc(window.firebase.db, 'usernames', userId));
          if (!usernameDoc.exists() || !usernameDoc.data()?.uid) {
            console.warn(`Username not found: ${userId}, falling back to UID`);
            actualUserId = userId;
          } else {
            actualUserId = usernameDoc.data().uid;
            console.log(`Resolved username ${userId} to UID ${actualUserId}`);
          }
        }
        sessionStorage.removeItem(`userProfile_${actualUserId}`);
        const userDoc = await window.firebase.getDoc(window.firebase.doc(window.firebase.db, 'users', actualUserId));
        const defaultPicture = 'https://placehold.co/40x40?text=User';
        if (!userDoc.exists()) {
          console.warn(`No user profile for UID: ${actualUserId}, using defaults`);
          return {
            username: 'Unknown User',
            profilePicture: defaultPicture,
            uid: actualUserId,
            dob: '',
            gender: '',
            race: '',
            relationshipType: '',
            height: 0,
            weight: 0,
            bodyType: '',
            zipCode: ''
          };
        }
        const data = userDoc.data();
        let profilePicture = defaultPicture;
        if (data.images?.mainProfilePic?.url && data.images?.mainProfilePic?.active) {
          profilePicture = data.images.mainProfilePic.url;
          try {
            new URL(profilePicture);
            console.log(`Valid profile picture URL for ${actualUserId}: ${profilePicture}`);
          } catch {
            console.warn(`Invalid profile picture URL for ${actualUserId}: ${profilePicture}, using default`);
            profilePicture = defaultPicture;
          }
        } else {
          console.log(`No active profile picture for ${actualUserId}, using default`);
        }
        const profile = {
          username: data.basicInfo?.username || data.username || 'Unknown User',
          profilePicture,
          uid: actualUserId,
          dob: data.basicInfo?.dateOfBirth || '',
          gender: data.basicInfo?.genderIdentity || '',
          race: data.physicalAttributes?.ethnicity || '',
          relationshipType: data.basicInfo?.relationshipStatus || '',
          height: parseInt(data.physicalAttributes?.height, 10) || 0,
          weight: parseInt(data.physicalAttributes?.weight, 10) || 0,
          bodyType: data.physicalAttributes?.bodyType || '',
          zipCode: data.locationLogistics?.zipCode || ''
        };
        console.log(`Fetched profile for ${actualUserId}:`, profile);
        sessionStorage.setItem(`userProfile_${actualUserId}`, JSON.stringify(profile));
        return profile;
      } catch (error) {
        console.error('fetchUserProfile error:', error.message, error.stack);
        return {
          username: 'Unknown User',
          profilePicture: 'https://placehold.co/40x40?text=User',
          uid: userId,
          dob: '',
          gender: '',
          race: '',
          relationshipType: '',
          height: 0,
          weight: 0,
          bodyType: '',
          zipCode: ''
        };
      }
    };

    const Header = ({ user, setUser }) => {
      const [isMenuOpen, setIsMenuOpen] = React.useState(false);
      const [email, setEmail] = React.useState('');
      const [password, setPassword] = React.useState('');
      const [loginError, setLoginError] = React.useState(null);
      const [displayName, setDisplayName] = React.useState('User');
      const [unreadCount, setUnreadCount] = React.useState(0);
      const firebase = window.firebase;

      React.useEffect(() => {
        console.log('Header: user prop:', user);
        const loadUserProfile = async () => {
          if (user?.uid) {
            const profile = await fetchUserProfile(user.uid);
            setDisplayName(profile.username || 'User');
            console.log('Header: Fetched profile for displayName:', { uid: user.uid, username: profile.username });
            if (!user.profile?.username) {
              setUser(prev => ({ ...prev, profile }));
            }
          } else {
            setDisplayName('User');
          }
        };
        loadUserProfile();
      }, [user?.uid]);

      React.useEffect(() => {
        if (!user?.uid || !firebase.db) return;
        const unsubscribe = firebase.onSnapshot(
          firebase.collection(firebase.db, `users/${user.uid}/unreadConversations`),
          (snapshot) => {
            let totalUnread = 0;
            snapshot.forEach(doc => {
              totalUnread += doc.data().unreadCount || 0;
            });
            setUnreadCount(totalUnread);
            console.log('Unread count updated:', totalUnread);
          },
          (error) => {
            console.error('Unread count snapshot error:', error);
          }
        );
        return () => unsubscribe();
      }, [user?.uid]);

      const debounce = (fn, delay) => {
        let timeout;
        return (...args) => {
          clearTimeout(timeout);
          timeout = setTimeout(() => fn(...args), delay);
        };
      };

      const handleLogin = async (e) => {
        e.preventDefault();
        if (!firebase?.auth) {
          setLoginError('Authentication service not available.');
          return;
        }
        try {
          setLoginError(null);
          const userCredential = await firebase.signInWithEmailAndPassword(firebase.auth, email, password);
          const user = userCredential.user;
          const profile = await fetchUserProfile(user.uid);
          await firebase.setDoc(
            firebase.doc(firebase.db, 'users', user.uid),
            { loginStatus: 'logged_in', lastLogin: firebase.serverTimestamp() },
            { merge: true }
          );
          setEmail('');
          setPassword('');
          setUser({
            ...user,
            profile,
            loginStatus: 'logged_in'
          });
          setDisplayName(profile.username || 'User');
          console.log('Login successful, user data:', { uid: user.uid, username: profile.username });
        } catch (error) {
          console.error('Login error:', error);
          setLoginError(`Login error: ${error.message || 'An unexpected error occurred'}`);
        }
      };

      const handleLogout = debounce(async () => {
        if (!firebase?.auth) {
          setLoginError('Authentication service not available.');
          return;
        }
        try {
          if (user) {
            await firebase.setDoc(
              firebase.doc(firebase.db, 'users', user.uid),
              { loginStatus: 'logged_out', lastLogout: firebase.serverTimestamp() },
              { merge: true }
            );
            sessionStorage.removeItem(`userProfile_${user.uid}`);
          }
          await firebase.signOut(firebase.auth);
          setUser(null);
          setDisplayName('User');
          setIsMenuOpen(false);
          console.log('Logout successful');
        } catch (error) {
          console.error('Logout error:', error);
          setLoginError(`Logout error: ${error.message || 'An unexpected error occurred'}`);
        }
      }, 300);

      return (
        <nav className="msgHeader bg-primary shadow-md">
          <div className="container mx-auto px-2 sm:px-4 py-2 flex items-center justify-between">
            <div className="logo-container">
              <a href="/">
                <img
                  src="./img/RealVibin.png"
                  alt="RealVibin Logo"
                  className="h-12 sm:h-16 md:h-20 w-auto"
                />
              </a>
            </div>
            <div className="auth-container hidden md:flex items-center space-x-4">
              {loginError && (
                <div className="text-red-200 text-sm">{loginError}</div>
              )}
              {user && user.loginStatus === 'logged_in' ? (
                <div className="flex items-center space-x-2">
                  <a
                    href="signup.html"
                    className="text-white font-semibold hover:underline"
                  >
                    {displayName}
                  </a>
                  <a
                    href="messages.html"
                    className="relative text-white hover:text-white"
                  >
                    <svg
                      className="h-6 w-6"
                      fill="none"
                      stroke="currentColor"
                      viewBox="0 0 24 24"
                    >
                      <path
                        strokeLinecap="round"
                        strokeLinejoin="round"
                        strokeWidth="2"
                        d="M7 8h10M7 12h4m1 8l-4-4H5a2 2 0 01-2-2V6a2 2 0 012-2h14a2 2 0 012 2v8a2 2 0 01-2 2h-3l-4 4z"
                      />
                    </svg>
                    {unreadCount > 0 && (
                      <span className="absolute -top-1 -right-1 bg-secondary text-white text-xs rounded-full h-5 w-5 flex items-center justify-center">
                        {unreadCount}
                      </span>
                    )}
                  </a>
                  <button
                    type="button"
                    className="bg-secondary text-white font-semibold py-2 px-4 rounded-lg hover:bg-red-700 transition"
                    onClick={handleLogout}
                  >
                    Logout
                  </button>
                </div>
              ) : (
                <div className="flex items-center space-x-2">
                  <div className="flex flex-col space-y-2 w-full md:flex-row md:space-y-0 md:space-x-2">
                    <input
                      type="email"
                      placeholder="Email"
                      value={email}
                      onChange={(e) => setEmail(e.target.value)}
                      className="form-input"
                      required
                      autoComplete="email"
                    />
                    <input
                      type="password"
                      placeholder="Password"
                      value={password}
                      onChange={(e) => setPassword(e.target.value)}
                      className="form-input"
                      required
                      autoComplete="current-password"
                    />
                    <button
                      onClick={handleLogin}
                      className="bg-primary text-white font-semibold py-2 px-4 rounded-lg hover:bg-blue-700 transition"
                    >
                      Login
                    </button>
                  </div>
                  <a
                    href="signup.html"
                    className="bg-primary text-white font-semibold py-2 px-4 rounded-lg hover:bg-blue-700 transition text-sm"
                  >
                    Need an account?
                  </a>
                </div>
              )}
            </div>
            <div className="md:hidden flex items-center">
              <button
                onClick={() => setIsMenuOpen(!isMenuOpen)}
                className="text-white hover:text-white focus:outline-none"
                type="button"
              >
                <svg
                  className="h-6 w-6"
                  fill="none"
                  stroke="currentColor"
                  viewBox="0 0 24 24"
                >
                  <path
                    strokeLinecap="round"
                    strokeLinejoin="round"
                    strokeWidth="2"
                    d={isMenuOpen ? 'M6 18L18 6M6 6l12 12' : 'M4 6h16M4 12h16M4 18h16'}
                  />
                </svg>
              </button>
            </div>
          </div>
          {isMenuOpen && (
            <div className="md:hidden bg-primary shadow-md px-2 py-4">
              {loginError && (
                <div className="text-red-200 text-sm mb-2">{loginError}</div>
              )}
              {user && user.loginStatus === 'logged_in' ? (
                <div className="flex flex-col space-y-2">
                  <a
                    href="signup.html"
                    className="text-white font-semibold hover:underline text-center"
                  >
                    {displayName}
                  </a>
                  <a
                    href="messages.html"
                    className="text-white font-semibold hover:underline text-center"
                  >
                    Messages
                    {unreadCount > 0 && (
                      <span className="bg-secondary text-white text-xs rounded-full h-5 w-5 flex items-center justify-center ml-2">
                        {unreadCount}
                      </span>
                    )}
                  </a>
                  <button
                    type="button"
                    className="bg-secondary text-white font-semibold py-2 px-4 rounded-lg hover:bg-red-700 transition"
                    onClick={handleLogout}
                  >
                    Logout
                  </button>
                </div>
              ) : (
                <div className="flex flex-col space-y-2">
                  <div className="flex flex-col space-y-2">
                    <input
                      type="email"
                      placeholder="Email"
                      value={email}
                      onChange={(e) => setEmail(e.target.value)}
                      className="form-input"
                      required
                      autoComplete="email"
                    />
                    <input
                      type="password"
                      placeholder="Password"
                      value={password}
                      onChange={(e) => setPassword(e.target.value)}
                      className="form-input"
                      required
                      autoComplete="current-password"
                    />
                    <button
                      onClick={handleLogin}
                      className="bg-primary text-white font-semibold py-2 px-4 rounded-lg hover:bg-blue-700 transition"
                    >
                      Login
                    </button>
                  </div>
                  <a
                    href="signup.html"
                    className="bg-primary text-white font-semibold py-2 px-4 rounded-lg hover:bg-blue-700 transition text-center text-sm"
                  >
                    Need an account?
                  </a>
                </div>
              )}
            </div>
          )}
        </nav>
      );
    };

    function MessagesApp() {
  const [viewerOpen, setViewerOpen] = React.useState(false);
  const [currentImageIndex, setCurrentImageIndex] = React.useState(0);
  const [user, setUser] = React.useState(null);
  const [loading, setLoading] = React.useState(true);
  const [conversations, setConversations] = React.useState([]);
  const [selectedChatId, setSelectedChatId] = React.useState(null);
  const [messages, setMessages] = React.useState([]);
  const [newMessage, setNewMessage] = React.useState('');
  const [image, setImage] = React.useState(null);
  const [previewImageUrl, setPreviewImageUrl] = React.useState(null);
  const [uploading, setUploading] = React.useState(false);
  const [error, setError] = React.useState(null);
  const [failedImages, setFailedImages] = React.useState(new Set());
  const fileInputRef = React.useRef(null);
  const messagesEndRef = React.useRef(null);
  const [otherState1, setOtherState1] = React.useState(null);
  const [otherState2, setOtherState2] = React.useState(null);
  const firebase = window.firebase;

  const markMessagesAsRead = React.useCallback(async (chatId) => {
    if (!user || !chatId) {
      console.warn('markMessagesAsRead: Missing user or chatId', { user, chatId });
      return;
    }
    console.log('Marking messages as read for chat', chatId);
    try {
      const convoRef = firebase.doc(firebase.db, 'conversations', chatId);
      const convoSnap = await firebase.getDoc(convoRef);
      if (!convoSnap.exists()) {
        console.warn('Conversation does not exist:', chatId);
        setError('Conversation not found.');
        return;
      }
      const convoData = convoSnap.data();
      if (!convoData.participants.includes(user.uid)) {
        console.warn('User not a participant in conversation:', { chatId, uid: user.uid });
        setError('You do not have access to this conversation.');
        return;
      }

      const messagesRef = firebase.collection(firebase.db, `conversations/${chatId}/messages`);
      const unreadQuery = firebase.query(
        messagesRef,
        firebase.where('senderId', '!=', user.uid),
        firebase.where('read', '==', false)
      );
      const snapshot = await firebase.getDocs(unreadQuery);
      if (snapshot.empty) {
        console.log('No unread messages to mark for chat', chatId);
        const unreadRef = firebase.doc(firebase.db, `users/${user.uid}/unreadConversations`, chatId);
        await firebase.setDoc(unreadRef, {
          unreadCount: 0,
          lastMessageTimestamp: firebase.serverTimestamp()
        }, { merge: true });
        return;
      }

      const batch = firebase.writeBatch(firebase.db);
      snapshot.forEach(doc => {
        batch.update(doc.ref, { read: true });
      });
      batch.update(convoRef, {
        unreadCount: 0,
        [`unreadCounts.${user.uid}`]: 0
      });
      const unreadRef = firebase.doc(firebase.db, `users/${user.uid}/unreadConversations`, chatId);
      batch.set(unreadRef, {
        unreadCount: 0,
        lastMessageTimestamp: firebase.serverTimestamp()
      }, { merge: true });
      await batch.commit();
      console.log('Messages marked as read, unreadCount reset', { chatId, count: snapshot.size });
    } catch (error) {
      console.error('Error marking messages as read:', error);
      setError(`Failed to update read status: ${error.message}`);
      if (error.code === 'permission-denied') {
        console.error('Permission denied. Verify Firestore rules and conversation participants:', {
          chatId,
          uid: user.uid
        });
      } else if (error.code === 'failed-precondition' && error.message.includes('index')) {
        console.error('Missing Firestore index. Create it in Firebase Console.');
      }
    }
  }, [user, firebase, setError]);

  const debounce = (fn, delay) => {
    let timeout;
    return (...args) => {
      clearTimeout(timeout);
      timeout = setTimeout(() => fn(...args), delay);
    };
  };
  const debouncedMarkMessagesAsRead = React.useCallback(debounce(markMessagesAsRead, 300), [markMessagesAsRead]);

  console.log('MessagesApp hooks declared:', {
    viewerOpen, currentImageIndex, user, loading, conversations,
    selectedChatId, messages, newMessage, image, previewImageUrl, uploading, error,
    failedImages, fileInputRef, messagesEndRef, otherState1, otherState2
  });

  React.useEffect(() => {
    if (!firebase) {
      setError('Firebase not initialized.');
      setLoading(false);
      return;
    }
    const initializeAuth = async () => {
      try {
        await firebase.setPersistence(firebase.auth, firebase.browserSessionPersistence);
        console.log('Auth persistence set to browserSessionPersistence');
        const unsubscribe = firebase.onAuthStateChanged(firebase.auth, async (currentUser) => {
          if (currentUser) {
            const profile = await fetchUserProfile(currentUser.uid);
            setUser({ ...currentUser, profile, loginStatus: 'logged_in' });
            console.log('Auth state updated:', { uid: currentUser.uid, username: profile.username });
          } else {
            setUser(null);
            setError('Please log in to view messages.');
            window.location.href = 'index.html';
          }
          setLoading(false);
        }, (err) => {
          console.error('Auth state error:', err);
          setError('Authentication error: ' + err.message);
          setLoading(false);
        });
        return () => unsubscribe();
      } catch (error) {
        console.error('Auth initialization error:', error);
        setError('Authentication initialization error: ' + error.message);
        setLoading(false);
      }
    };
    initializeAuth();
  }, [firebase]);

  React.useEffect(() => {
    const urlParams = new URLSearchParams(window.location.search);
    const recipientId = urlParams.get('recipient');
    if (recipientId && user?.uid) {
      console.log('Triggering startConversation for recipient:', recipientId);
      startConversation(recipientId);
    }
  }, [user?.uid]);

  React.useEffect(() => {
    if (!user?.uid || !firebase.db) return;
    console.log('Setting up conversations snapshot for user:', user.uid);
    const q = firebase.query(
      firebase.collection(firebase.db, 'conversations'),
      firebase.where('participants', 'array-contains', user.uid),
      firebase.orderBy('lastMessage.timestamp', 'desc')
    );
    const unsubscribeConvos = firebase.onSnapshot(q, async (snapshot) => {
      const convos = await Promise.all(snapshot.docs.map(async (doc) => {
        const data = doc.data();
        console.log('Processing conversation:', doc.id, data);
        const otherUserId = data.participants.find(id => id !== user.uid);
        const profile = await fetchUserProfile(otherUserId);
        const unreadDoc = await firebase.getDoc(
          firebase.doc(firebase.db, `users/${user.uid}/unreadConversations`, doc.id)
        );
        const unreadCount = unreadDoc.exists() ? unreadDoc.data().unreadCount || 0 : 0;
        return {
          id: doc.id,
          otherUserId,
          otherUsername: profile.username,
          profilePicture: profile.profilePicture,
          lastMessage: data.lastMessage || {},
          unreadCount
        };
      }));

      const unsubscribeUnread = {};
      convos.forEach(convo => {
        const unreadRef = firebase.doc(firebase.db, `users/${user.uid}/unreadConversations`, convo.id);
        unsubscribeUnread[convo.id] = firebase.onSnapshot(unreadRef, (unreadSnap) => {
          const unreadData = unreadSnap.exists() ? unreadSnap.data() : { unreadCount: 0 };
          console.log('Unread count updated for convo:', convo.id, unreadData.unreadCount);
          setConversations(prev => {
            const updatedConvos = prev.map(c => {
              if (c.id === convo.id) {
                return { ...c, unreadCount: unreadData.unreadCount || 0 };
              }
              return c;
            });
            return updatedConvos;
          });
        }, (err) => {
          console.error('Unread snapshot error for convo:', convo.id, err);
        });
      });

      console.log('Conversations updated:', convos);
      setConversations(convos);

      return () => {
        Object.values(unsubscribeUnread).forEach(unsub => unsub());
      };
    }, (err) => {
      console.error('Conversations snapshot error:', err.code, err.message, err.stack);
      setError('Failed to load conversations: ' + err.message);
    });

    return () => {
      unsubscribeConvos();
    };
  }, [user?.uid, firebase.db]);

  React.useEffect(() => {
    if (!user?.uid || !firebase.db) return;
    const q = firebase.query(
      firebase.collection(firebase.db, 'conversations'),
      firebase.where('participants', 'array-contains', user.uid)
    );
    const unsubscribe = firebase.onSnapshot(q, async (snapshot) => {
      for (const change of snapshot.docChanges()) {
        if (change.type !== 'modified') continue;
        const convo = change.doc.data();
        const convoId = change.doc.id;
        if (convoId === selectedChatId) continue;
        const lastMessage = convo.lastMessage || {};
        if (lastMessage.senderId === user.uid || lastMessage.read) continue;
        const unreadRef = firebase.doc(firebase.db, `users/${user.uid}/unreadConversations`, convoId);
        const unreadSnap = await firebase.getDoc(unreadRef);
        const currentUnread = unreadSnap.exists() ? unreadSnap.data().unreadCount : 0;
        await firebase.setDoc(unreadRef, {
          unreadCount: currentUnread + 1,
          lastMessageTimestamp: firebase.serverTimestamp()
        }, { merge: true });
        console.log(`Incremented unread count for ${convoId}: ${currentUnread + 1}`);
      }
    }, (err) => {
      console.error('Unread count snapshot error:', err);
      setError('Failed to update unread count: ' + err.message);
    });
    return () => unsubscribe();
  }, [user?.uid, selectedChatId, firebase.db]);

  React.useEffect(() => {
    if (!selectedChatId || !user || !firebase.db) {
      setMessages([]);
      return;
    }
    console.log('Setting up messages snapshot for chat:', selectedChatId);
    const q = firebase.query(
      firebase.collection(firebase.db, `conversations/${selectedChatId}/messages`),
      firebase.orderBy('timestamp', 'asc')
    );
    const unsubscribe = firebase.onSnapshot(q, (snapshot) => {
      const msgs = snapshot.docs.map(doc => ({
        id: doc.id,
        ...doc.data()
      }));
      setMessages(msgs);
      console.log('Messages updated:', msgs);
      debouncedMarkMessagesAsRead(selectedChatId);
    }, (err) => {
      console.error('Messages snapshot error:', err.code, err.message, err.stack);
      setError('Failed to load messages: ' + err.message);
    });
    return () => unsubscribe();
  }, [selectedChatId, user, firebase.db, debouncedMarkMessagesAsRead]);

  React.useEffect(() => {
    if (messages.length > 0 && messagesEndRef.current) {
      console.log('Scrolling to latest message');
      requestAnimationFrame(() => {
        messagesEndRef.current.scrollIntoView({ behavior: 'smooth' });
      });
    }
  }, [messages, selectedChatId]);

  // Clean up previewImageUrl to avoid memory leaks
  React.useEffect(() => {
    return () => {
      if (previewImageUrl) {
        console.log('Revoking preview image URL');
        URL.revokeObjectURL(previewImageUrl);
      }
    };
  }, [previewImageUrl]);

  const startConversation = async (recipientId) => {
      if (!user?.uid || !recipientId || user.uid === recipientId) {
        console.warn('Invalid startConversation params:', { userId: user?.uid, recipientId });
        return;
      }
      try {
        console.log('Starting conversation with recipientId:', recipientId);
        if (!firebase.auth.currentUser) {
          throw new Error('User not authenticated');
        }
        console.log('Authenticated user:', firebase.auth.currentUser.uid);
        const isUsername = !recipientId.match(/^[a-zA-Z0-9]{20,}$/);
        const recipientProfile = await fetchUserProfile(recipientId, isUsername);
        const recipientUserId = recipientProfile.uid;
        console.log('Recipient resolved:', { recipientId, recipientUserId, username: recipientProfile.username });
        if (user.uid === recipientUserId) {
          console.warn('Cannot start conversation with self:', recipientUserId);
          return;
        }
        const chatId = [user.uid, recipientUserId].sort().join('_');
        const convoRef = firebase.doc(firebase.db, 'conversations', chatId);
        console.log('Checking conversation:', chatId);
        const convoSnap = await firebase.getDoc(convoRef);
        if (!convoSnap.exists()) {
          console.log('Creating new conversation:', chatId);
          await firebase.setDoc(convoRef, {
            participants: [user.uid, recipientUserId],
            createdAt: firebase.serverTimestamp(),
            lastMessage: {},
            unreadCount: 0,
            unreadCounts: { [user.uid]: 0, [recipientUserId]: 0 }
          });
          console.log('New conversation created:', chatId);
          setConversations(prev => {
            const exists = prev.some(c => c.id === chatId);
            if (exists) return prev;
            const newConvo = {
              id: chatId,
              otherUserId: recipientUserId,
              otherUsername: recipientProfile.username,
              profilePicture: recipientProfile.profilePicture,
              lastMessage: {},
              unreadCount: 0
            };
            console.log('Added placeholder conversation:', newConvo);
            return [newConvo, ...prev];
          });
        } else {
          console.log('Existing conversation found:', chatId, convoSnap.data());
        }
        setSelectedChatId(chatId);
        console.log('Selected chat:', chatId);
      } catch (error) {
        console.error('startConversation error:', error.code, error.message, error.stack);
        setError('Failed to start conversation: ' + error.message);
      }
    };
    
  const handleImageChange = (e) => {
    const file = e.target.files[0];
    if (!file) {
      console.log('No file selected');
      return;
    }
    if (!file.type.startsWith('image/')) {
      console.error('Invalid file type:', file.type);
      setError('Please upload an image file.');
      setImage(null);
      setPreviewImageUrl(null);
      return;
    }
    console.log('Image selected:', file.name);
    setImage(file);
    setPreviewImageUrl(URL.createObjectURL(file));
    setError(null);
  };

  const cancelImage = () => {
    console.log('Cancelling image attachment');
    if (previewImageUrl) {
      URL.revokeObjectURL(previewImageUrl);
    }
    setImage(null);
    setPreviewImageUrl(null);
    if (fileInputRef.current) {
      fileInputRef.current.value = null;
    }
  };

  const uploadImage = async () => {
    if (!image) return null;
    setUploading(true);
    const formData = new FormData();
    formData.append('file', image);
    formData.append('upload_preset', window.CLOUDINARY_UPLOAD_PRESET);
    try {
      console.log('Uploading image to Cloudinary');
      const response = await fetch(`https://api.cloudinary.com/v1_1/${window.CLOUDINARY_CLOUD_NAME}/image/upload`, {
        method: 'POST',
        body: formData
      });
      const data = await response.json();
      if (data.secure_url) {
        console.log('Image uploaded:', data.secure_url);
        return data.secure_url;
      }
      throw new Error('Image upload failed');
    } catch (error) {
      console.error('Image upload error:', error);
      setError('Failed to upload image: ' + error.message);
      return null;
    } finally {
      setUploading(false);
    }
  };

  const sendMessage = async (e) => {
    e.preventDefault();
    if (!user || !selectedChatId || (!newMessage.trim() && !image)) return;
    try {
      console.log('Sending message:', { selectedChatId, userId: user.uid });
      setError(null);
      const imageUrl = await uploadImage();
      const messageData = {
        text: newMessage.trim() || null,
        imageUrl: imageUrl || null,
        senderId: user.uid,
        timestamp: firebase.serverTimestamp(),
        read: false
      };
      const messagesRef = firebase.collection(firebase.db, `conversations/${selectedChatId}/messages`);
      await firebase.addDoc(messagesRef, messageData);
      const convoRef = firebase.doc(firebase.db, 'conversations', selectedChatId);
      await firebase.updateDoc(convoRef, {
        lastMessage: messageData
      });
      setNewMessage('');
      setImage(null);
      setPreviewImageUrl(null);
      if (fileInputRef.current) fileInputRef.current.value = null;
      console.log('Message sent:', messageData);
    } catch (error) {
      console.error('Send message error:', error.code, error.message, error.stack);
      setError('Failed to send message: ' + error.message);
    }
  };

  const imageUrls = (messages || []).filter(msg => msg?.imageUrl && !failedImages.has(msg.imageUrl)).map(msg => msg.imageUrl);
  console.log('MessagesApp render', { user, conversations, messages, selectedChatId, imageUrls, previewImageUrl });

  const openImageViewer = (index) => {
    console.log('Opening viewer at index', index);
    if (index >= 0 && index < imageUrls.length) {
      setCurrentImageIndex(index);
      setViewerOpen(true);
    }
  };

  const closeImageViewer = () => {
    console.log('Closing viewer');
    setViewerOpen(false);
  };

  const prevImage = () => {
    setCurrentImageIndex(prev => (prev === 0 ? imageUrls.length - 1 : prev - 1));
  };

  const nextImage = () => {
    setCurrentImageIndex(prev => (prev === imageUrls.length - 1 ? 0 : prev + 1));
  };

  return (
    <div className="flex flex-col h-screen overflow-hidden">
      <Header user={user} setUser={setUser} />
      <div className="container">
        {loading ? (
          <div className="text-center mt-20">
            <p className="text-gray-600">Loading user...</p>
          </div>
        ) : !user ? (
          <div className="text-center mt-20">
            <p className="text-gray-600">Redirecting to login...</p>
          </div>
        ) : (
          <>
            {error && (
              <div className="bg-red-100 text-red-700 p-4 mb-4 rounded">
                {error}
              </div>
            )}
            <div className="message-container flex flex-col md:flex-row">
              <div
                className={`message-list w-full md:w-1/3 ${
                  selectedChatId ? 'hidden md:block' : 'block'
                } transition-transform duration-300 ${
                  selectedChatId ? '-translate-x-full md:translate-x-0' : 'translate-x-0'
                }`}
              >
                <h2 className="text-xl font-semibold text-primary mb-2">Conversations</h2>
                {(!conversations || conversations.length === 0) ? (
                  <p className="text-gray-600">No conversations yet.</p>
                ) : (
                  conversations.map(convo => (
                    <div
                      key={convo?.id || 'unknown'}
                      className={`flex items-center p-3 cursor-pointer rounded-lg hover:bg-gray-100 ${
                        selectedChatId === convo?.id ? 'bg-gray-200' : ''
                      }`}
                      onClick={() => {
                        console.log('Selecting chat', convo?.id);
                        setSelectedChatId(convo?.id);
                        debouncedMarkMessagesAsRead(convo?.id);
                      }}
                    >
                      <img
                        src={convo?.profilePicture || 'https://placehold.co/40x40?text=User'}
                        alt={convo?.otherUsername || 'User'}
                        className="w-10 h-10 rounded-full mr-3 object-cover"
                        onError={(e) => {
                          e.target.src = 'https://placehold.co/40x40?text=User';
                        }}
                      />
                      <div className="flex-1">
                        <div className="flex justify-between">
                          <span className="font-semibold">{convo?.otherUsername || 'Unknown'}</span>
                          <span className="text-sm text-gray-600">
                            {convo?.lastMessage?.timestamp?.toDate().toLocaleTimeString() || ''}
                          </span>
                        </div>
                        <div className="flex justify-between">
                          <p className="text-sm text-gray-600 truncate">
                            {convo?.lastMessage?.text || (convo?.lastMessage?.imageUrl ? '[Image]' : '')}
                          </p>
                          {convo?.unreadCount > 0 && (
                            <span className="bg-secondary text-white text-xs rounded-full h-5 w-5 flex items-center justify-center">
                              {convo?.unreadCount}
                            </span>
                          )}
                        </div>
                      </div>
                    </div>
                  ))
                )}
              </div>
              <div
                className={`conversation-view w-full md:w-2/3 flex flex-col ${
                  selectedChatId ? 'block' : 'hidden md:block'
                } transition-transform duration-300 ${
                  selectedChatId ? 'translate-x-0' : 'translate-x-full md:translate-x-0'
                }`}
              >
                {selectedChatId ? (
                  <>
                    <div className="flex items-center p-4 bg-primary text-white rounded-t-lg">
                      <button
                        className="md:hidden mr-4 text-white"
                        onClick={() => {
                          console.log('Back to list');
                          setSelectedChatId(null);
                        }}
                      >
                        ← Back
                      </button>
                      <h2 className="text-xl font-semibold">
                        <a
                          href={`/profile.html?uid=${
                            conversations.find(c => c?.id === selectedChatId)?.otherUserId || ''
                          }`}
                          className="text-white underline hover:opacity-75"
                        >
                          {conversations.find(c => c?.id === selectedChatId)?.otherUsername ||
                            'Conversation'}
                        </a>
                      </h2>
                    </div>
                    <div className="messages-area flex-1 overflow-y-auto p-4">
                      {(messages || []).map((msg, msgIndex) => (
                        <div
                          key={msg?.id || `msg-${msgIndex}`}
                          className={`flex mb-2 ${msg?.senderId === user.uid ? 'justify-end' : 'justify-start'}`}
                        >
                          <div
                            className={`message-bubble p-3 rounded-lg ${
                              msg?.senderId === user.uid ? 'bg-primary text-white' : 'bg-gray-200 text-gray-800'
                            }`}
                          >
                            {msg?.text && <p>{msg.text}</p>}
                            {msg?.imageUrl && (
                              <div
                                className="cursor-pointer"
                                onClick={() => {
                                  const index = imageUrls.indexOf(msg.imageUrl);
                                  console.log('Image clicked, index', index);
                                  openImageViewer(index);
                                }}
                              >
                                <img
                                  src={msg.imageUrl}
                                  alt="Shared image"
                                  className="max-w-[200px] rounded-lg mt-2"
                                  onError={(e) => {
                                    setFailedImages(prev => new Set(prev).add(msg.imageUrl));
                                    e.target.src = 'https://placehold.co/200x200?text=Image+Error';
                                  }}
                                />
                              </div>
                            )}
                            <span
                              className={`text-xs block mt-1 ${
                                msg?.senderId === user.uid ? 'text-white' : 'text-gray-500'
                              }`}
                            >
                              {msg?.timestamp?.toDate().toLocaleTimeString() || ''}
                            </span>
                          </div>
                        </div>
                      ))}
                      <div ref={messagesEndRef} />
                    </div>
                    <form className="message-input flex flex-col space-y-2 p-4 border-t">
                      <div className="flex items-center space-x-2">
                        <input
                          type="text"
                          placeholder="Type a message..."
                          value={newMessage || ''}
                          onChange={(e) => setNewMessage(e.target.value)}
                          className="form-input flex-1 border-gray-300 focus:border-primary focus:ring focus:ring-primary focus:ring-opacity-50"
                        />
                        <input
                          type="file"
                          accept="image/*"
                          onChange={handleImageChange}
                          className="hidden"
                          ref={fileInputRef}
                          id="image-upload"
                        />
                        <label
                          htmlFor="image-upload"
                          className="bg-gray-200 p-2 rounded-lg cursor-pointer hover:bg-gray-300"
                        >
                          <svg
                            className="h-6 w-6 text-gray-600"
                            fill="none"
                            stroke="currentColor"
                            viewBox="0 0 24 24"
                          >
                            <path
                              strokeLinecap="round"
                              strokeLinejoin="round"
                              strokeWidth="2"
                              d="M15.172 7l-6.586 6.586a2 2 0 002.828 2.828l6.586-6.586a4 4 0 00-5.656-5.656L5.586 10.758a6 6 0 008.486 8.486L20.758 12"
                            />
                          </svg>
                        </label>
                        <button
                          type="submit"
                          className="bg-primary text-white font-semibold py-2 px-4 rounded-lg hover:bg-blue-700 transition"
                          disabled={uploading}
                          onClick={sendMessage}
                        >
                          {uploading ? 'Sending...' : 'Send'}
                        </button>
                      </div>
                      {previewImageUrl && (
                        <div className="relative w-[100px] h-[100px]">
                          <img
                            src={previewImageUrl}
                            alt="Image preview"
                            className="w-full h-full object-cover rounded-lg"
                          />
                          <button
                            className="absolute top-0 right-0 bg-red-500 text-white rounded-full w-6 h-6 flex items-center justify-center hover:bg-red-600"
                            onClick={cancelImage}
                          >
                            ✕
                          </button>
                        </div>
                      )}
                    </form>
                  </>
                ) : (
                  <div className="flex-1 flex items-center justify-center text-gray-600">
                    Select a conversation to start chatting.
                  </div>
                )}
              </div>
            </div>
            {viewerOpen && (
              <div className="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-[2000]">
                <div className="relative bg-white rounded-lg max-w-[90%] max-h-[90vh] md:max-w-3xl">
                  <button
                    className="absolute top-2 right-2 text-gray-600 hover:text-gray-800"
                    onClick={closeImageViewer}
                  >
                    <svg className="h-6 w-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M6 18L18 6M6 6l12 12" />
                    </svg>
                  </button>
                  {imageUrls.length > 0 && currentImageIndex < imageUrls.length ? (
                    <>
                      <img
                        src={imageUrls[currentImageIndex]}
                        alt="Conversation image"
                        className="w-full h-auto max-h-[80vh] object-contain rounded-lg"
                        onError={(e) => {
                          setFailedImages(prev => new Set(prev).add(imageUrls[currentImageIndex]));
                          e.target.src = 'https://placehold.co/400x400?text=Image+Error';
                        }}
                      />
                      {imageUrls.length > 1 && (
                        <>
                          <button
                            className="absolute left-2 top-1/2 transform -translate-y-1/2 bg-primary text-white p-2 rounded-full hover:bg-blue-700"
                            onClick={prevImage}
                          >
                            <svg className="h-6 w-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M15 19l-7-7 7-7" />
                            </svg>
                          </button>
                          <button
                            className="absolute right-2 top-1/2 transform -translate-y-1/2 bg-primary text-white p-2 rounded-full hover:bg-blue-700"
                            onClick={nextImage}
                          >
                            <svg className="h-6 w-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M9 5l7 7-7 7" />
                            </svg>
                          </button>
                        </>
                      )}
                    </>
                  ) : (
                    <p className="p-4 text-gray-600">No images available.</p>
                  )}
                </div>
              </div>
            )}
          </>
        )}
      </div>
    </div>
  );
}

    try {
      console.log('Rendering React app');
      const root = ReactDOM.createRoot(document.getElementById('root'));
      root.render(
        <ErrorBoundary>
          <MessagesApp />
        </ErrorBoundary>
      );
      console.log('React app rendered');
    } catch (error) {
      console.error('Render error:', error);
      document.getElementById('root').innerHTML = '<div className="error"><h2>Error</h2><p>Failed to render: ' + error.message + '</p></div>';
    }
  </script>
</body>
</html>